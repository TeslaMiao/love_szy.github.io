<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>心动</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <script>
  // ---------- Settings ----------
  const settings = {
    particles: {
      length: 1200,       // particle pool size (supports heart + bursts)
      duration: 2.2,      // particle lifetime (sec)
      velocity: 120,      // initial speed (px/sec) for heart outline
      effect: -0.85,      // acceleration as a factor of initial velocity
      size: 30            // particle sprite size (px)
    },
    beat: {
      amp: 0.12,          // heart scale amplitude
      freq: 1.2           // beats per second
    },
    stars: {
      count: 350,
      twinkleSpeed: 2.0
    },
    meteors: {
      spawnChancePerSec: 0.35, // probability per second to spawn a meteor
      speedMin: 600,
      speedMax: 900,
      life: 1.2,               // seconds
      tail: 220
    },
    clickBurst: {
      count: 160,
      speedMin: 140,
      speedMax: 420
    }
  };

  // ---------- RAF Polyfill ----------
  (function(){
    let lastTime = 0, vendors = ['ms','moz','webkit','o'];
    for (let x=0; x<vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] ||
                                    window[vendors[x]+'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(cb) {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = window.setTimeout(() => cb(currTime + timeToCall), timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = id => clearTimeout(id);
    }
  }());

  // ---------- Math helpers ----------
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(a, b) { return a + Math.random() * (b - a); }

  // ---------- Point ----------
  class Point {
    constructor(x=0, y=0){ this.x=x; this.y=y; }
    clone(){ return new Point(this.x, this.y); }
    length(len){
      if (len === undefined) return Math.sqrt(this.x*this.x + this.y*this.y);
      this.normalize();
      this.x *= len; this.y *= len; return this;
    }
    normalize(){
      const l = this.length() || 1;
      this.x /= l; this.y /= l; return this;
    }
  }

  // ---------- Particle ----------
  class Particle {
    constructor(){
      this.position = new Point();
      this.velocity = new Point();
      this.acceleration = new Point();
      this.age = 0;
    }
    initialize(x,y,dx,dy){
      this.position.x = x; this.position.y = y;
      this.velocity.x = dx; this.velocity.y = dy;
      this.acceleration.x = dx * settings.particles.effect;
      this.acceleration.y = dy * settings.particles.effect;
      this.age = 0;
    }
    update(dt){
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.velocity.x += this.acceleration.x * dt;
      this.velocity.y += this.acceleration.y * dt;
      this.age += dt;
    }
    draw(ctx, image){
      // ease-out cubic
      function ease(t){ return (--t) * t * t + 1; }
      const life = this.age / settings.particles.duration;
      const size = image.width * ease(life);
      ctx.globalAlpha = 1 - life;
      ctx.drawImage(image, this.position.x - size/2, this.position.y - size/2, size, size);
      ctx.globalAlpha = 1;
    }
  }

  // ---------- Particle Pool ----------
  class ParticlePool {
    constructor(length){
      this.particles = Array.from({length}, () => new Particle());
      this.firstActive = 0;
      this.firstFree = 0;
      this.duration = settings.particles.duration;
    }
    add(x,y,dx,dy){
      const p = this.particles[this.firstFree];
      p.initialize(x,y,dx,dy);
      this.firstFree = (this.firstFree + 1) % this.particles.length;
      if (this.firstActive === this.firstFree){
        this.firstActive = (this.firstActive + 1) % this.particles.length;
      }
    }
    update(dt){
      const {particles} = this;
      let i;
      if (this.firstActive < this.firstFree){
        for (i=this.firstActive; i<this.firstFree; i++) particles[i].update(dt);
      } else {
        for (i=this.firstActive; i<particles.length; i++) particles[i].update(dt);
        for (i=0; i<this.firstFree; i++) particles[i].update(dt);
      }
      while (this.firstActive !== this.firstFree &&
             this.particles[this.firstActive].age >= this.duration){
        this.firstActive = (this.firstActive + 1) % particles.length;
      }
    }
    draw(ctx, img){
      const {particles} = this;
      let i;
      if (this.firstActive < this.firstFree){
        for (i=this.firstActive; i<this.firstFree; i++) particles[i].draw(ctx,img);
      } else {
        for (i=this.firstActive; i<particles.length; i++) particles[i].draw(ctx,img);
        for (i=0; i<this.firstFree; i++) particles[i].draw(ctx,img);
      }
    }
  }

  // ---------- Scene Setup ----------
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');

  const pool = new ParticlePool(settings.particles.length);
  const particleRate = settings.particles.length / settings.particles.duration; // per sec
  let time;
  let width, height, centerX, centerY;

  function resize(){
    width = canvas.width = canvas.clientWidth;
    height = canvas.height = canvas.clientHeight;
    centerX = width / 2;
    centerY = height / 2;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- Heart math ----------
  function heartPoint(t){
    // -PI .. PI
    return new Point(
      160 * Math.pow(Math.sin(t), 3),
      130 * Math.cos(t) - 50 * Math.cos(2*t) - 20 * Math.cos(3*t) - 10 * Math.cos(4*t) + 25
    );
  }

  // ---------- Create heart sprite ----------
  const heartImage = (() => {
    const c = document.createElement('canvas');
    const cctx = c.getContext('2d');
    c.width = settings.particles.size;
    c.height = settings.particles.size;

    function to(t){
      const p = heartPoint(t);
      p.x = c.width/2 + p.x * c.width / 350;
      p.y = c.height/2 - p.y * c.height / 350;
      return p;
    }
    cctx.beginPath();
    let t = -Math.PI;
    let p = to(t);
    cctx.moveTo(p.x, p.y);
    while (t < Math.PI){
      t += 0.01;
      p = to(t);
      cctx.lineTo(p.x, p.y);
    }
    cctx.closePath();

    const grad = cctx.createLinearGradient(0,0,0,c.height);
    grad.addColorStop(0, '#ffb3d1');
    grad.addColorStop(1, '#ff5e9c');
    cctx.fillStyle = grad;
    cctx.shadowColor = '#ff77aa';
    cctx.shadowBlur = 12;
    cctx.fill();

    const img = new Image();
    img.src = c.toDataURL();
    return img;
  })();

  // ---------- Starfield & Meteors ----------
  const stars = Array.from({length: settings.stars.count}, () => ({
    x: Math.random(),
    y: Math.random(),
    r: Math.random()*1.1 + 0.2,
    tw: Math.random() * Math.PI * 2
  }));

  const meteors = [];
  function spawnMeteor(){
    const fromTop = Math.random() < 0.5;
    const startX = rand(-width*0.2, width*1.2);
    const startY = fromTop ? rand(-height*0.1, height*0.2) : rand(-height*0.2, height*0.1);
    const angle = rand(Math.PI*0.12, Math.PI*0.28); // down-right
    const speed = rand(settings.meteors.speedMin, settings.meteors.speedMax);
    meteors.push({
      x: startX, y: startY,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      life: 0
    });
  }

  function drawStars(dt){
    // subtle parallax twinkle
    for (const s of stars){
      s.tw += dt * settings.stars.twinkleSpeed;
      const alpha = 0.5 + 0.5 * Math.sin(s.tw);
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(s.x*width, s.y*height, s.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function updateMeteors(dt){
    // spawn
    if (Math.random() < settings.meteors.spawnChancePerSec * dt){
      spawnMeteor();
    }
    // update & draw
    for (let i = meteors.length - 1; i >= 0; i--){
      const m = meteors[i];
      m.life += dt;
      m.x += m.vx * dt;
      m.y += m.vy * dt;

      // draw tail
      const tailX = m.x - m.vx / (settings.meteors.speedMin) * settings.meteors.tail;
      const tailY = m.y - m.vy / (settings.meteors.speedMin) * settings.meteors.tail;
      const grad = ctx.createLinearGradient(m.x, m.y, tailX, tailY);
      grad.addColorStop(0, 'rgba(255,255,255,0.9)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(m.x, m.y);
      ctx.lineTo(tailX, tailY);
      ctx.stroke();

      if (m.life > settings.meteors.life ||
          m.x > width+50 || m.y > height+50){
        meteors.splice(i,1);
      }
    }
  }

  // ---------- Click Burst ----------
  function burst(x, y){
    for (let i=0; i<settings.clickBurst.count; i++){
      const angle = Math.random()*Math.PI*2;
      const speed = rand(settings.clickBurst.speedMin, settings.clickBurst.speedMax);
      const dx = Math.cos(angle)*speed;
      const dy = Math.sin(angle)*speed;
      pool.add(x, y, dx, dy);
    }
  }
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    burst(x, y);
  });

  // ---------- Day Counter ----------
  const togetherStart = new Date('2025-02-06T00:00:00');
  function togetherDays(){
    const now = new Date();
    const diff = now - togetherStart;
    // 第1天从开始当天算起（+1）
    return Math.floor(diff / (24*60*60*1000)) + 1;
  }

  // ---------- Text helpers ----------
  function drawCenteredText(text, y, font, fillStyle, shadowBlur=18, shadowColor='rgba(255,120,170,0.9)'){
    ctx.save();
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = shadowColor;
    ctx.shadowBlur = shadowBlur;
    ctx.fillStyle = fillStyle;
    ctx.fillText(text, centerX, y);
    ctx.restore();
  }

  function drawWrappedText(text, y, maxWidth, lineHeight, font, fillStyle, align='center'){
    ctx.save();
    ctx.font = font;
    ctx.fillStyle = fillStyle;
    ctx.textAlign = align;
    ctx.textBaseline = 'alphabetic';
    const words = text.split('');
    let line = '';
    const lines = [];
    for (let ch of words){
      const test = line + ch;
      const w = ctx.measureText(test).width;
      if (w > maxWidth && line !== ''){
        lines.push(line);
        line = ch;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);
    let yy = y;
    for (const l of lines){
      ctx.fillText(l, centerX, yy);
      yy += lineHeight;
    }
    ctx.restore();
  }

  // ---------- Render Loop ----------
  function render(){
    requestAnimationFrame(render);

    const newTime = Date.now() / 1000;
    const dt = newTime - (time || newTime);
    time = newTime;

    // background
    ctx.clearRect(0,0,width,height);
    // subtle space gradient
    const bg = ctx.createRadialGradient(centerX, centerY, Math.min(width,height)*0.1, centerX, centerY, Math.max(width,height)*0.9);
    bg.addColorStop(0, '#06070a');
    bg.addColorStop(1, '#000000');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,width,height);

    drawStars(dt);
    updateMeteors(dt);

    // heart beating scale
    const beat = 1 + settings.beat.amp * Math.sin(2*Math.PI*settings.beat.freq * time);

    // heart particle generation
    const amount = particleRate * dt;
    for (let i=0; i<amount; i++){
      const pos = heartPoint(Math.PI - 2*Math.PI*Math.random());
      // scale by beat
      const sx = pos.x * beat;
      const sy = pos.y * beat;
      const dir = new Point(sx, sy).clone().length(settings.particles.velocity);
      pool.add(centerX + sx, centerY - sy, dir.x, -dir.y);
    }

    // update and draw particles
    pool.update(dt);
    pool.draw(ctx, heartImage);

    // overlay texts
    // Top: 顶层标题
    const grad = ctx.createLinearGradient(centerX-100, 0, centerX+100, 0);
    grad.addColorStop(0, '#ffd1e6');
    grad.addColorStop(1, '#ff6aa2');
    drawCenteredText('星河烂漫 · 满眼是你', height * 0.13,
      "700 56px 'STKaiti','KaiTi','Hiragino Sans GB','Microsoft YaHei','Noto Serif SC',serif",
      grad, 28, 'rgba(255,140,180,0.95)'
    );

    // Bottom center: 我们已经在一起第 xxx 天啦
    const days = togetherDays();
    const bottomMsg = `我们已经在一起 ${days} 天啦`;
    drawCenteredText(bottomMsg, height * 0.84,
      "600 26px 'STKaiti','KaiTi','Microsoft YaHei','Noto Serif SC',serif",
      '#ffd9e8', 12, 'rgba(255,128,170,0.8)'
    );

    // Bottom-most romantic line (wrapped)
    const poem = '想你~ 想你~';
    ctx.shadowBlur = 0;
    drawWrappedText(poem, height - 32, Math.min(width*0.86, 980),
      28, "500 20px 'STKaiti','KaiTi','Microsoft YaHei','Noto Serif SC',serif",
      'rgba(255, 220, 235, 0.9)'
    );
  }

  // ---------- Bootstrap ----------
  setTimeout(render, 10);
  </script>
</body>
</html>
